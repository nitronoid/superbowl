
// Returns x squared
float sqr(float x)
{
    return x * x;
}

// Returns the sign of x
int signum(float x)
{
    return (0.0 < x) - (x < 0.0);
}

// Linear interpolation at between x and y, at t
float lerp(float x, float y, float t) 
{
  return (1 - t) * x + t * y;
}

// Combines two smooth steps to create a smooth bump, 0 -> 1 -> 0
float smoothpulse (float e0, float e1, float e2, float e3, float x)
{
    return smoothstep(e0,e1,x) - smoothstep(e2,e3,x);
}

// Creates an infinite trail of smooth bumps
float smoothpulsetrain (float e0, float e1, float e2, float e3, float period, float x)
{
    return smoothpulse(e0, e1, e2, e3, mod(x,period));
}

// Wrapper for smoothpulsetrain that assumes the smoothpulse is uniform
float smoothpulsetraineven (float e0, float e1, float fuzz, float period, float x)
{
    return smoothpulsetrain(e0-fuzz, e0, e1, e1+fuzz, period,x);
}

float eyezone (point pos, float fuzz, float gap, float thickness, float warp, float expo)
{
    float recipExpo = 1.0/expo;
    // calculate the current radius
    float r = hypot(pos[0],pos[1]);
    // calculate the sum of the normalised x and y
    float sum = (pos[0] + pos[1]) / r;
    // calculate the period of the pulse train based on our sum and exp
    float period = gap * lerp(1, pow(sum,recipExpo), warp);
    float elipses = 1 - smoothpulsetraineven(thickness, thickness + period, fuzz, period, pow(r,recipExpo));
    float mask = 1 - smoothstep(1,1,hypot(pos[0]-(0.7),pos[1]-(0.7)));
    return mask * clamp(elipses,0,1);
}

float eyes (point _pos, normal norm, float scale, point translate, float fuzz, float gap, float thickness, float warp, float expo)
{
    point posA = _pos;
    point posB = _pos;
    // Add some noise based on P, and scale in x
    posA += noise("perlin", posA)/15;
    posB += noise("perlin", posA)/15;
    float stretch = 1.35;
    posA[1] *= stretch;
    posB *= point(-1, stretch, 1);
    
    // Position the eye
    posA = posA/scale - translate;
    posB = posB/scale - translate;

    float eyes = eyezone(posA, fuzz, gap, thickness + noise("perlin", posA/2)/20, warp, expo)
               + eyezone(posB, fuzz, gap, thickness + noise("perlin", posB/2)/20, warp, expo);
    if(norm[2] < 0) eyes = 0;

    return eyes;
}

// 
float posnoise(point x)
{
    return noise("perlin", x/2)/20;
}

float turb (point _pos, float _frequency)
{
    point pos = _pos;
    float ret = 0;
    float frequency = _frequency;
    for(int i = 0; i < 8; ++i)
	{
        ret += abs((float)noise("perlin",pos*frequency))/frequency;
        frequency*=2.1;
	}
    return ret;
}

float slicednoise (point pos, float frequency, float fuzz, float slice)
{
    return smoothstep(slice, slice + fuzz, turb(pos, frequency));
}

float brushed (point _pos, float frequency, point stretch)
{
    point pos = _pos;
    pos += (vector)noise("perlin",pos*frequency)/frequency;
    pos *= stretch;
    return turb(pos, frequency*2);
}

float dots(point _pos)
{
    point pos = _pos;
    return 1 - slicednoise(pos, 4, 0.01, 0.02);
}

float veins(point _pos, float frequency, float stretch)
{
    point pos = _pos;
    pos[0] *= stretch;
    return 1 - slicednoise(pos, frequency, 0.05, 0.01);
}

point randPos(point _pos, float rand, float scale)
{
    return _pos + (vector)noise("perlin", _pos + rand) * scale;
}

float blendNoise(point pos, float freq)
{
    return (float)noise("perlin",randPos(pos,0,1) * freq)/freq;
}

shader oiledWood(
    float scale            = 1,
    point translate        = point(1,1,0),
    float warp             = 0,
    float expo             = 1,
    float thickness        = 0.1,
    float gap              = thickness * 2,
    float fuzz             = thickness / 2,
    output float rough     = 0,
    output float spec      = 0,
    output float disp      = 0,
    output float resultF   = 0,
    output color resultRGB = 0
)
{
    // Transform the point to object space so it sticks to the object
    point shaderP = transform("object", P);

    // Detail layers
    float layers[8] = {
        // large darken
        1 - clamp(1.0,0.0,blendNoise(randPos(shaderP + point(1,0,0), 4, 5), 0.005)),
        // thin darkening noise
        turb(shaderP, 4) * blendNoise(randPos(shaderP, 2, 15), 0.01),
        // small variance
        turb(shaderP, 4) * blendNoise(shaderP, 2) * 2,
        // light brushed
        brushed(shaderP, 0.25, point(20,1,1)) * slicednoise(randPos(shaderP, 2, 1), 0.5, 5, 0.2),
        // dark brushed
        brushed(shaderP, 0.5, point(5,25,1)) * slicednoise(randPos(shaderP, 3, 1), 0.6, 3, 0.5),
        // rough wood
        veins(shaderP, 6, 10) * slicednoise(randPos(shaderP, 1, 1), 0.3, 3, 1.1),
        // veins
        veins(shaderP, 4, 2) * slicednoise(randPos(shaderP, 4, 1), 1, 1.25, 0.15) * 2,
        // wood chips
        slicednoise(shaderP, 2.0, 0.01, 0.4)
    };

    color cols[8] = {
        color(0.036, 0.008, 0.001),
        color(0.03, 0.009, 0.0),
        color(0.08, 0.002, 0.0),
        color(0.703, 0.188, 0.108),
        color(0.707, 0.090, 0.021),
        color(0.960, 0.436, 0.149),
        color(0.843, 0.326, 0.176),
        color(1, 0.31, 0.171)
    };

    // Add a base color
    resultRGB = color(0.093, 0.02, 0.003);
    // Layer the colors on top of eachother using the float masks
    for(int i = 0; i < arraylength(layers); ++i) 
    {
        resultF += layers[i];
        resultRGB = mix(resultRGB, cols[i], layers[i]);
    }
    spec = 0.2 + (float)noise("perlin", shaderP * 5)/5;

    // Outputs
    disp = eyes(shaderP, transform("object", N), scale, point(0.21,0.2,0), fuzz, gap, thickness, warp, expo);

    disp += (resultF/25);
    rough = 0.115+slicednoise(randPos(shaderP, 2, 1), 0.5, 5, 0.2)*1.5;
}