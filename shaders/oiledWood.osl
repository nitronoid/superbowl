
float turb (point _pos, float _frequency)
{
    point pos = _pos;
    float ret = 0;
    float frequency = _frequency;
    for(int i = 0; i < 8; ++i)
	{
        ret += abs((float)noise("perlin",pos*frequency))/frequency;
        frequency*=2.1;
	}
    return ret;
}

float slicednoise (point pos, float frequency, float fuzz, float slice)
{
    return smoothstep(slice, slice + fuzz, turb(pos, frequency));
}

float brushed (point _pos, float frequency, point stretch)
{
    point pos = _pos;
    pos += (vector)noise("perlin",pos*frequency)/frequency;
    pos *= stretch;
    return turb(pos, frequency*2);
}

float dots(point _pos)
{
    point pos = _pos;
    return 1 - slicednoise(pos, 4, 0.01, 0.02);
}

float veins(point _pos, float frequency, float stretch)
{
    point pos = _pos;
    pos[0] *= stretch;
    return 1 - slicednoise(pos, frequency, 0.05, 0.01);
}

shader oiledWood(
    output float resultF   = 0,
    output color resultRGB = 0
)
{
    // Transform the point to object space so it sticks to the object
    point shaderP = transform("object", P);

    // Detail layers
    float layers[6] = {
        turb(shaderP, 4) * clamp(1.0, 0.0, (float)noise("perlin",shaderP)/2),
        // rough wood
        veins(shaderP, 6, 10) * slicednoise(shaderP, 0.3, 3, 1.1),
        // wood chips
        slicednoise(shaderP, 2.0, 0.1, 0.4),
        // light brushed
        brushed(shaderP, 0.25, point(20,1,1)) * slicednoise(shaderP, 0.5, 5, 0.2) * 0.5,
        // dark brushed
        brushed(shaderP, 0.5, point(5,25,1)) * slicednoise(shaderP, 0.6, 3, 0.5),
        // veins
        veins(shaderP, 4, 2) * slicednoise(shaderP, 1, 1.25, 0.15) 
    };

    // Outputs
    // sum all the layers
    for(int i = 0; i < arraylength(layers); ++i) resultF += layers[i];
    resultRGB = mix(color(0,0,0), color(1,1,1), resultF);
    //resultRGB = mix(color(0.03,0.0035,0.002), color(0.84,0.75,0.453), resultF);
}