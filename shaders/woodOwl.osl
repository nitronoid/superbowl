
// Returns x squared
float sqr(float x)
{
    return x * x;
}

// Returns the sign of x
int signum(float x)
{
    return (0.0 < x) - (x < 0.0);
}

// Linear interpolation at between x and y, at t
float lerp(float x, float y, float t) 
{
  return (1 - t) * x + t * y;
}

// Combines two smooth steps to create a smooth bump, 0 -> 1 -> 0
float smoothpulse (float e0, float e1, float e2, float e3, float x)
{
    return smoothstep(e0,e1,x) - smoothstep(e2,e3,x);
}

// Creates an infinite trail of smooth bumps
float smoothpulsetrain (float e0, float e1, float e2, float e3, float period, float x)
{
    return smoothpulse(e0, e1, e2, e3, mod(x,period));
}

// Wrapper for smoothpulsetrain that assumes the smoothpulse is uniform
float smoothpulsetraineven (float e0, float e1, float fuzz, float period, float x)
{
    return smoothpulsetrain(e0-fuzz, e0, e1, e1+fuzz, period,x);
}

float eyezone (point pos, float fuzz, float gap, float thickness, float warp, float expo)
{
    float recipExpo = 1.0/expo;
    // calculate the current radius
    float r = hypot(pos[0],pos[1]);
    // calculate the sum of the normalised x and y
    float sum = (pos[0] + pos[1]) / r;
    // calculate the period of the pulse train based on our sum and exp
    float period = gap * lerp(1, pow(sum,recipExpo), warp);
    float elipses = 1 - smoothpulsetraineven(thickness, thickness + period, fuzz, period, pow(r,recipExpo));
    float mask = 1 - smoothstep(1,1,hypot(pos[0]-(0.7),pos[1]-(0.7)));
    return mask * clamp(elipses,0,1);
}

// 
float posnoise(point x)
{
    return noise("perlin", x/2)/20;
}

shader woodOwl(
    float scale            = 1,
    point translate        = point(0,0,0),
    float warp             = 0,
    float expo             = 1,
    float thickness        = 0.1,
    float gap              = thickness * 2,
    float fuzz             = thickness / 2,
    output float resultF   = 0,
    output color resultRGB = 0
)
{
    // Transform the point to shader space so it sticks to the object
    point eyeTransform = transform("object", P);

    // Add some noise based on P, and scale in x
    eyeTransform += noise("perlin", eyeTransform/2)/20;
    eyeTransform[1] *= 1.15;
    
    // Position the eye
    eyeTransform = eyeTransform/scale + translate;

    // Outputs
    resultF = eyezone(eyeTransform, fuzz, gap, thickness + noise("perlin", eyeTransform/2)/20, warp, expo);
    normal nm = transform("object", N);
   // resultF *= smoothstep(1, 0, nm[2] < 0);
    if(nm[2] < 0) resultF = 0;
    resultRGB = mix(color(0,0,0), color(1,1,1), resultF);
}
